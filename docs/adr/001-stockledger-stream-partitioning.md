# ADR-001: StockLedger Stream Partitioning Strategy

**Status:** Accepted  
**Date:** 2026-02-07  
**Decision Makers:** Implementation Team  
**Relates To:** Mitigation V-2 (expected-version append), Requirement 1 (Stock Movement Ledger), Task 7.3.4

---

## Context

The StockLedger is an event-sourced aggregate that uses Marten's expected-version append (V-2) for atomic balance validation. The choice of stream partition key directly impacts:

1. **V-2 Atomicity**: Balance validation and event append must be atomic within a single stream
2. **Throughput**: Single-stream serialization limits write throughput
3. **Balance Query Efficiency**: Computing balance requires reading the relevant stream(s)

### Options Considered

| Option | Partition Key | Stream ID Example | V-2 Atomicity | Throughput |
|--------|--------------|-------------------|---------------|------------|
| **A. Warehouse-level** | `warehouseId` | `stock-ledger:main` | ✅ Full (all movements serialize) | ⚠️ Limited by single stream |
| **B. (warehouseId, location, sku)** | `warehouseId:location:sku` | `stock-ledger:WH1:LOC-A:SKU-001` | ✅ Per (location, SKU) scope | ✅ High parallelism |
| **C. Location-level** | `location` | `stock-ledger:R3-C6` | ✅ Per location scope | ⚠️ Moderate |

---

## Decision

**Use (warehouseId, location, sku) stream partitioning.**

Stream ID format: `stock-ledger:{warehouseId}:{location}:{sku}`

The stream ID is generated by a single helper function `StockLedgerStreamId.For(warehouseId, location, sku)` which serves as the **single source of truth** for stream identity.

### Stream Routing per Movement Type

| Movement Type | Primary Stream | Rationale |
|--------------|----------------|-----------|
| RECEIPT, ADJUSTMENT_IN | TO location's stream | Inbound: credit the destination |
| DISPATCH, ADJUSTMENT_OUT | FROM location's stream | Outbound: V-2 balance check at source |
| TRANSFER | FROM location's stream | V-2 balance check on debit side; TO-side credit is eventually consistent via projection |

### Rationale

1. **V-2 Serialization per (location, sku)**: Expected-version append protects the exact balance scope where contention occurs — a specific SKU at a specific location. This is the natural invariant boundary.
2. **High Throughput**: Movements affecting different (location, sku) pairs append to different streams with zero contention. Only concurrent modifications to the *same* SKU at the *same* location serialize.
3. **Avoid Warehouse-Wide Contention**: A single warehouse stream would force ALL movements in a warehouse to serialize through one stream, limiting throughput to ~1000 appends/sec regardless of how many locations/SKUs exist. Rejected.
4. **Clean Balance Query**: Loading one stream gives you the complete balance for that (location, sku) — no filtering needed.
5. **Future Scalability**: Individual (location, sku) streams can theoretically be distributed across database partitions or nodes.

### Trade-offs Accepted

- **Transfer is two-stream**: A TRANSFER from LOC-A to LOC-B of SKU-1 only appends to the FROM stream (LOC-A). The TO-side balance (LOC-B) is eventually consistent via the `LocationBalanceProjection`. This means the TO-side aggregate does NOT immediately reflect the credit.
- **More streams**: Each unique (warehouseId, location, sku) creates its own stream. For a warehouse with 500 locations × 1000 SKUs, this could mean up to 500K streams. Marten handles this well with PostgreSQL.
- **Cross-location balance queries**: Total balance for a SKU across all locations requires reading multiple streams or using the `LocationBalanceProjection` (eventually consistent).

---

## Enforcement

The stream ID is enforced via `StockLedgerStreamId.For()` in `LKvitai.MES.Domain`. All code that interacts with StockLedger streams MUST use this helper. Direct string construction of stream IDs is prohibited.

```csharp
// ✅ Correct: Use the helper
var streamId = StockLedgerStreamId.For("WH1", "LOC-A", "SKU-001");

// ❌ Wrong: Direct string construction
var streamId = "stock-ledger:WH1:LOC-A:SKU-001";

// ❌ Wrong: Warehouse-only stream (obsolete)
var streamId = StockLedgerStreamId.For("WH1");
```

---

## Rejected Alternative: Warehouse-Level Stream

**Option A** (`stock-ledger:{warehouseId}`) was rejected because:

- All movements in a warehouse serialize through one stream — high contention under load
- Balance validation for a specific (location, sku) requires in-memory filtering of the entire warehouse event history
- Aggregate hydration cost grows linearly with ALL movements in the warehouse, not just the relevant (location, sku)
- Does not match the natural invariant boundary (balance is per location+sku, not per warehouse)

Earlier design documents (`design.md`, `implementation-blueprint.md`) referenced warehouse-level streams. This ADR supersedes those references.

---

## Consequences

- **Positive**: V-2 serialization at the correct granularity — no unnecessary contention
- **Positive**: Single source of truth for stream ID makes future migration safe
- **Positive**: Aggregate hydration is fast (only events for one location+sku)
- **Negative**: Transfer movements are two-stream; TO-side is eventually consistent
- **Negative**: More streams to manage (mitigated by Marten/PostgreSQL capabilities)

---

## References

- `design.md` Section "Aggregate 1: StockLedger" — Concurrency Control (MITIGATION V-2)
- `implementation-blueprint.md` Section 1.2 — Event Stream Partitioning Strategy (superseded by this ADR)
- `implementation-task-universe.md` Task 7.3.4 — StockLedger Partitioning Strategy
- Requirement 1.9–1.11 — Atomic balance validation with optimistic concurrency
