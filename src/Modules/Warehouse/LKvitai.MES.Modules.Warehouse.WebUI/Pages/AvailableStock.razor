@page "/available-stock"
@implements IDisposable
@inject StockClient StockApiClient
@inject IJSRuntime JavaScript
@using System.Diagnostics

<PageTitle>Available Stock - LKvitai.MES</PageTitle>

<h3>Available Stock</h3>

<StockFilters Warehouses="@_warehouses"
              Filters="@_filters"
              OnSearch="HandleSearchAsync" />

@if (_apiError is not null)
{
    <ErrorBanner Message="@BuildErrorMessage(_apiError)"
                 TraceId="@_apiError.TraceId"
                 OnRetry="RetryAsync"
                 OnDismiss="DismissError" />
}

<div class="card shadow-sm position-relative">
    <LoadingSpinner IsLoading="@(_isLoadingWarehouses || _isSearching)" />

    <div class="card-body">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <div class="text-muted">
                @_summaryText
            </div>
            <button class="btn btn-outline-secondary btn-sm"
                    @onclick="ExportCsvAsync"
                    disabled="@(_items.Count == 0)">
                Export CSV
            </button>
        </div>

        @if (!_hasSearched)
        {
            <p class="text-muted mb-0">Enter at least one filter and click Search.</p>
        }
        else
        {
            <MudDataGrid T="AvailableStockItemDto"
                         @ref="_grid"
                         @key="_gridRenderKey"
                         ServerData="LoadServerDataAsync"
                         Filterable="false"
                         SortMode="SortMode.None"
                         Dense="true"
                         Hover="true"
                         RowsPerPage="@_pageSize"
                         Loading="@_isSearching">
                <Columns>
                    <PropertyColumn Property="x => x.WarehouseId" Title="Warehouse" />
                    <PropertyColumn Property="x => x.Location" Title="Location" />
                    <PropertyColumn Property="x => x.SKU" Title="SKU" />
                    <TemplateColumn Title="Physical Qty">
                        <CellTemplate>@context.Item.PhysicalQty.ToString("N2")</CellTemplate>
                    </TemplateColumn>
                    <TemplateColumn Title="Reserved Qty">
                        <CellTemplate>@context.Item.ReservedQty.ToString("N2")</CellTemplate>
                    </TemplateColumn>
                    <TemplateColumn Title="Available Qty">
                        <CellTemplate>@context.Item.AvailableQty.ToString("N2")</CellTemplate>
                    </TemplateColumn>
                    <TemplateColumn Title="Last Updated">
                        <CellTemplate>
                            @context.Item.LastUpdated.ToLocalTime().ToString("yyyy-MM-dd HH:mm:ss")
                            <span class="ms-2"><StaleBadge LastUpdated="context.Item.LastUpdated" /></span>
                        </CellTemplate>
                    </TemplateColumn>
                </Columns>
                <NoRecordsContent>
                    <MudText Typo="Typo.body2" Class="text-muted">No stock found matching filters.</MudText>
                </NoRecordsContent>
                <PagerContent>
                    <MudDataGridPager T="AvailableStockItemDto" />
                </PagerContent>
            </MudDataGrid>

            @if (_items.Count == 0 && _apiError is null && !_isSearching)
            {
                <p class="text-muted mb-0">No stock found matching filters.</p>
            }
        }
    </div>
</div>

@code {
    private MudDataGrid<AvailableStockItemDto>? _grid;
    private IReadOnlyList<WarehouseDto> _warehouses = Array.Empty<WarehouseDto>();
    private IReadOnlyList<AvailableStockItemDto> _items = Array.Empty<AvailableStockItemDto>();

    private AvailableStockSearchFilters _filters = new();

    private bool _isLoadingWarehouses = true;
    private bool _isSearching;
    private bool _hasSearched;

    private int _page = 1;
    private int _pageSize = 50;
    private int _totalCount;
    private int _gridRenderKey;

    private ApiException? _apiError;
    private bool _isDisposed;
    private readonly CancellationTokenSource _disposeCts = new();

    private int _totalPages => Math.Max(1, (int)Math.Ceiling(_totalCount / (double)Math.Max(1, _pageSize)));

    private string _summaryText => _hasSearched
        ? $"Showing {_items.Count} item(s) on page {_page} of {_totalPages}."
        : "Search has not been run yet.";

    protected override async Task OnInitializedAsync()
    {
        await LoadWarehousesAsync();
    }

    public void Dispose()
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;
        _disposeCts.Cancel();
        _disposeCts.Dispose();
    }

    private async Task LoadWarehousesAsync()
    {
        if (_isDisposed)
        {
            return;
        }

        _isLoadingWarehouses = true;
        _apiError = null;

        try
        {
            _warehouses = await StockApiClient.GetWarehousesAsync(_disposeCts.Token);
            if (_isDisposed)
            {
                return;
            }
        }
        catch (ApiException ex)
        {
            if (_isDisposed)
            {
                return;
            }

            _apiError = ex;
            _warehouses = Array.Empty<WarehouseDto>();
        }
        catch (OperationCanceledException) when (_disposeCts.IsCancellationRequested)
        {
            return;
        }
        catch (Exception ex)
        {
            if (_isDisposed)
            {
                return;
            }

            _apiError = new ApiException(
                new ProblemDetailsModel
                {
                    Title = "Warehouse lookup failed",
                    Detail = ex.Message,
                    Status = 500,
                    TraceId = Activity.Current?.Id
                },
                500);
            _warehouses = Array.Empty<WarehouseDto>();
        }
        finally
        {
            if (!_isDisposed)
            {
                _isLoadingWarehouses = false;
            }
        }
    }

    private async Task HandleSearchAsync(AvailableStockSearchFilters filters)
    {
        if (_isDisposed)
        {
            return;
        }

        _filters = filters;

        if (!_filters.HasAtLeastOneFilter)
        {
            _hasSearched = false;
            _items = Array.Empty<AvailableStockItemDto>();
            _totalCount = 0;
            _apiError = null;
            return;
        }

        _page = 1;
        _gridRenderKey++;
        await InvokeAsync(StateHasChanged);
    }

    private async Task<SearchResultState> SearchAsync(int page, int pageSize)
    {
        if (_isDisposed || !_filters.HasAtLeastOneFilter)
        {
            return SearchResultState.Empty;
        }

        _isSearching = true;
        _apiError = null;
        _hasSearched = true;

        try
        {
            var result = await StockApiClient.SearchAvailableStockAsync(
                _filters.Warehouse,
                _filters.Location,
                _filters.Sku,
                _filters.IncludeVirtual,
                page,
                pageSize,
                _disposeCts.Token);

            if (_isDisposed)
            {
                return SearchResultState.Empty;
            }

            _items = result.Items;
            _totalCount = result.TotalCount;
            _page = page;
            _pageSize = pageSize;

            return new SearchResultState(result.Items, result.TotalCount);
        }
        catch (ApiException ex)
        {
            if (_isDisposed)
            {
                return SearchResultState.Empty;
            }

            _apiError = ex;
            _items = Array.Empty<AvailableStockItemDto>();
            _totalCount = 0;
            return SearchResultState.Empty;
        }
        catch (OperationCanceledException) when (_disposeCts.IsCancellationRequested)
        {
            return SearchResultState.Empty;
        }
        catch (Exception ex)
        {
            if (_isDisposed)
            {
                return SearchResultState.Empty;
            }

            _apiError = new ApiException(
                new ProblemDetailsModel
                {
                    Title = "Stock search failed",
                    Detail = ex.Message,
                    Status = 500,
                    TraceId = Activity.Current?.Id
                },
                500);
            _items = Array.Empty<AvailableStockItemDto>();
            _totalCount = 0;
            return SearchResultState.Empty;
        }
        finally
        {
            if (!_isDisposed)
            {
                _isSearching = false;
            }
        }
    }

    private async Task<GridData<AvailableStockItemDto>> LoadServerDataAsync(GridState<AvailableStockItemDto> state)
    {
        if (!_hasSearched || !_filters.HasAtLeastOneFilter)
        {
            _items = Array.Empty<AvailableStockItemDto>();
            _totalCount = 0;
            return new GridData<AvailableStockItemDto>
            {
                Items = Array.Empty<AvailableStockItemDto>(),
                TotalItems = 0
            };
        }

        var requestedPageSize = state.PageSize > 0 ? state.PageSize : _pageSize;
        var result = await SearchAsync(state.Page + 1, requestedPageSize);

        return new GridData<AvailableStockItemDto>
        {
            Items = result.Items,
            TotalItems = result.TotalCount
        };
    }

    private async Task RetryAsync()
    {
        if (_isDisposed)
        {
            return;
        }

        if (_hasSearched)
        {
            if (_grid is not null)
            {
                await _grid.ReloadServerData();
            }
            return;
        }

        await LoadWarehousesAsync();
    }

    private void DismissError() => _apiError = null;

    private async Task ExportCsvAsync()
    {
        if (_isDisposed)
        {
            return;
        }

        if (_items.Count == 0)
        {
            return;
        }

        var csv = BuildCsv(_items);
        var filename = $"available-stock-{DateTime.UtcNow:yyyyMMdd-HHmmss}.csv";
        await JavaScript.InvokeVoidAsync("csvExport.download", _disposeCts.Token, filename, csv);
    }

    private static string BuildCsv(IReadOnlyList<AvailableStockItemDto> rows)
    {
        var builder = new System.Text.StringBuilder();
        builder.AppendLine("Warehouse,Location,SKU,Physical Qty,Reserved Qty,Available Qty,Last Updated");

        foreach (var row in rows)
        {
            builder.Append(EscapeCsv(row.WarehouseId)).Append(',')
                .Append(EscapeCsv(row.Location)).Append(',')
                .Append(EscapeCsv(row.SKU)).Append(',')
                .Append(row.PhysicalQty.ToString("0.##")).Append(',')
                .Append(row.ReservedQty.ToString("0.##")).Append(',')
                .Append(row.AvailableQty.ToString("0.##")).Append(',')
                .Append(EscapeCsv(row.LastUpdated.ToString("O")))
                .AppendLine();
        }

        return builder.ToString();
    }

    private static string EscapeCsv(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return string.Empty;
        }

        if (value.Contains(',') || value.Contains('"') || value.Contains('\n') || value.Contains('\r'))
        {
            return "\"" + value.Replace("\"", "\"\"") + "\"";
        }

        return value;
    }

    private static string BuildErrorMessage(ApiException error)
    {
        if (error.ProblemDetails?.Errors is { Count: > 0 } fieldErrors)
        {
            var flattened = fieldErrors
                .SelectMany(entry => entry.Value.Select(message => $"{entry.Key}: {message}"));

            var details = string.Join("; ", flattened);
            return string.IsNullOrWhiteSpace(details) ? error.UserMessage : $"{error.UserMessage} {details}";
        }

        if (!string.IsNullOrWhiteSpace(error.ProblemDetails?.Detail))
        {
            return $"{error.UserMessage} {error.ProblemDetails.Detail}";
        }

        return error.UserMessage;
    }

    private sealed record SearchResultState(IReadOnlyList<AvailableStockItemDto> Items, int TotalCount)
    {
        public static readonly SearchResultState Empty = new(Array.Empty<AvailableStockItemDto>(), 0);
    }
}
