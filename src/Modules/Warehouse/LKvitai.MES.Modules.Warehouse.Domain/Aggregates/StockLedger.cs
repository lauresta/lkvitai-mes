using LKvitai.MES.Contracts.Events;
using LKvitai.MES.SharedKernel;

namespace LKvitai.MES.Modules.Warehouse.Domain.Aggregates;

/// <summary>
/// StockLedger aggregate — Event-sourced, append-only ledger of stock movements.
/// Single source of truth for stock quantity changes.
/// 
/// Partitioning (ADR-001): One stream per (warehouseId, location, sku).
///   Stream ID generated by <see cref="StockLedgerStreamId.For"/>.
///   Inbound movements → TO location's stream.
///   Outbound/Transfer → FROM location's stream (V-2 balance check on debit side).
///
/// Concurrency: Uses Marten expected-version append (V-2) for atomic balance validation.
/// Invariants:
///   - Quantity must be positive
///   - From location ≠ To location (for internal moves)
///   - Sufficient balance at FROM location for outbound movements (no negative balance)
/// </summary>
public class StockLedger
{
    // --- Marten aggregate identity & version ---
    // Marten uses Id to correlate with the stream key (string identity per ADR-001)
    public string Id { get; set; } = string.Empty;

    // Marten does not auto-populate this on AggregateStreamAsync;
    // we track it manually via the repository.
    public int Version { get; set; }

    // --- Internal balance state ---
    // Key: "location:sku", Value: current quantity
    private readonly Dictionary<string, decimal> _balances = new();

    /// <summary>
    /// Returns the current balance for a (location, SKU) pair.
    /// Returns 0 if no movements have been recorded for this combination.
    /// </summary>
    public decimal GetBalance(string location, string sku)
    {
        ArgumentNullException.ThrowIfNull(location);
        ArgumentNullException.ThrowIfNull(sku);
        return _balances.TryGetValue(BalanceKey(location, sku), out var qty) ? qty : 0m;
    }

    /// <summary>
    /// Returns all tracked balances as a read-only snapshot.
    /// Useful for testing / diagnostics.
    /// </summary>
    public IReadOnlyDictionary<string, decimal> GetAllBalances()
        => _balances.AsReadOnly();

    /// <summary>
    /// Validates domain invariants and produces a <see cref="StockMovedEvent"/>.
    /// Does NOT mutate aggregate state — the caller must append the event to the stream,
    /// and Marten will call <see cref="Apply(StockMovedEvent)"/> on hydration.
    /// </summary>
    /// <exception cref="DomainException">If quantity ≤ 0 or from == to for non-inbound.</exception>
    /// <exception cref="InsufficientBalanceException">If FROM location has insufficient stock.</exception>
    public StockMovedEvent RecordMovement(
        Guid movementId,
        string sku,
        decimal quantity,
        string fromLocation,
        string toLocation,
        string movementType,
        Guid operatorId,
        Guid? handlingUnitId = null,
        string? reason = null)
    {
        // --- Invariant: quantity must be positive ---
        if (quantity <= 0)
            throw new DomainException("Movement quantity must be greater than zero.");

        // --- Invariant: from ≠ to for non-inbound movements ---
        if (!MovementType.IsInbound(movementType)
            && !string.IsNullOrEmpty(fromLocation)
            && !string.IsNullOrEmpty(toLocation)
            && string.Equals(fromLocation, toLocation, StringComparison.OrdinalIgnoreCase))
        {
            throw new DomainException(
                $"From location '{fromLocation}' must differ from to location '{toLocation}'.");
        }

        // --- Invariant: sufficient balance (no negative balance) ---
        if (!MovementType.IsInbound(movementType) && !string.IsNullOrEmpty(fromLocation))
        {
            var currentBalance = GetBalance(fromLocation, sku);
            if (currentBalance < quantity)
                throw new InsufficientBalanceException(fromLocation, sku, quantity, currentBalance);
        }

        return new StockMovedEvent
        {
            MovementId = movementId,
            SKU = sku,
            Quantity = quantity,
            FromLocation = fromLocation,
            ToLocation = toLocation,
            MovementType = movementType,
            OperatorId = operatorId,
            HandlingUnitId = handlingUnitId,
            Reason = reason,
            Timestamp = DateTime.UtcNow
        };
    }

    // ----------------------------------------------------------------
    // Marten event application — called during aggregate hydration
    // ----------------------------------------------------------------

    /// <summary>
    /// Applies a StockMovedEvent to update internal balance state.
    /// Called by Marten when replaying events from the stream.
    /// </summary>
    public void Apply(StockMovedEvent e)
    {
        // Decrease balance at FROM location
        if (!string.IsNullOrEmpty(e.FromLocation))
        {
            var fromKey = BalanceKey(e.FromLocation, e.SKU);
            _balances[fromKey] = _balances.GetValueOrDefault(fromKey, 0m) - e.Quantity;
        }

        // Increase balance at TO location
        if (!string.IsNullOrEmpty(e.ToLocation))
        {
            var toKey = BalanceKey(e.ToLocation, e.SKU);
            _balances[toKey] = _balances.GetValueOrDefault(toKey, 0m) + e.Quantity;
        }
    }

    // ----------------------------------------------------------------
    // Helpers
    // ----------------------------------------------------------------

    private static string BalanceKey(string location, string sku)
        => $"{location}:{sku}";
}
